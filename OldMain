void resetState();

void getWaveEnemyEntities(int waveNumber, std::vector<Spawn>* spawns, std::vector<std::unique_ptr<Entity>>& entities, std::vector<std::unique_ptr<Enemy>>& enemies);

bool pauseEnemy = false;

Player* timpyPointer = nullptr;

SDL_Rect fullScreenRect = {0,0,WINDOW_WIDTH,WINDOW_HEIGHT};

State state;

void pauseScreen() {
    SDL_RenderClear(gameRenderer);

    SDL_Event e;

    while(SDL_PollEvent(&e) != 0) {
        if( e.type == SDL_QUIT ) {
            state.quit = true;
        } else if( e.type == SDL_KEYDOWN ) {
            if(e.key.keysym.sym == SDLK_ESCAPE) {
                state.menu = notInMenu;
            }
        } else if( e.type == SDL_JOYBUTTONDOWN ) {
            if(SDL_GameControllerGetButton(controller, SDL_GameControllerButton::SDL_CONTROLLER_BUTTON_A) == 1) {
                controllerEvent(state,MENU_CONTROL::select);
            } else if(SDL_GameControllerGetButton(controller, SDL_GameControllerButton::SDL_CONTROLLER_BUTTON_B) == 1) {
                state.menu = notInMenu;
            } else if(SDL_GameControllerGetButton(controller, SDL_GameControllerButton::SDL_CONTROLLER_BUTTON_DPAD_UP) == 1) {
                controllerEvent(state,MENU_CONTROL::up);
            } else if(SDL_GameControllerGetButton(controller, SDL_GameControllerButton::SDL_CONTROLLER_BUTTON_DPAD_DOWN) == 1) {
                controllerEvent(state,MENU_CONTROL::down);
            } else if(SDL_GameControllerGetButton(controller, SDL_GameControllerButton::SDL_CONTROLLER_BUTTON_DPAD_LEFT) == 1) {
                controllerEvent(state,MENU_CONTROL::left);
            } else if(SDL_GameControllerGetButton(controller, SDL_GameControllerButton::SDL_CONTROLLER_BUTTON_DPAD_RIGHT) == 1) {
                controllerEvent(state,MENU_CONTROL::right);
            }
        } else if(e.type == SDL_JOYDEVICEADDED ) {
            controllerEvent(state,MENU_CONTROL::connect);
            loadController();
        } else if (e.type == SDL_JOYDEVICEREMOVED) {
            controllerEvent(state,MENU_CONTROL::disconnect);
            controller = nullptr;
            state.controller = false;
        } else  if( e.type == SDL_MOUSEMOTION) {
            mouseMove(state);
        } else if(e.type == SDL_MOUSEBUTTONDOWN) {
            menuSelect(state);
        } else if( e.type == SDL_JOYAXISMOTION) {
            if(SDL_GameControllerGetAxis(controller, SDL_GameControllerAxis::SDL_CONTROLLER_AXIS_LEFTY) > JOYSTICK_DEAD_ZONE) {
                if(state.controllerStickReset) {
                    controllerEvent(state,MENU_CONTROL::down);
                    state.controllerStickReset = false;
                }
            } else if (SDL_GameControllerGetAxis(controller, SDL_GameControllerAxis::SDL_CONTROLLER_AXIS_LEFTY) < -JOYSTICK_DEAD_ZONE) {
                if(state.controllerStickReset) {
                    controllerEvent(state,MENU_CONTROL::up);
                    state.controllerStickReset = false;
                }
            } else {
                state.controllerStickReset = true;
            }
        }
    }

    renderMenu(state);
    SDL_SetRenderDrawColor(gameRenderer, 26, 26, 26, 255);
    SDL_RenderPresent(gameRenderer);
}

int main( int argc, char* args[] ) {

        SDL_Event e;
        Uint32 lastUpdate = SDL_GetTicks();

        Sound explosion("resources/sounds/shortExplosion.wav", 0,-1);
        Sound mediumExplosion("resources/sounds/mediumExplosion.wav", 0,-1);
        Sound song("resources/sounds/song.wav", -1,0);

        std::list<Explosion> explosions;

        UI_init(gameRenderer, state, &timpy);

        //Game Loop
        while(!state.quit) {
            resetState();

            std::list<Entity> eBullets;
            std::list<Bullet> bullets;

            if(controller != nullptr) {
                controllerEvent(state,MENU_CONTROL::connect);
            }

            while(!state.started && !state.quit) {
                startScreen();
            }

            state.camY = 0;
            state.camV = 0;

            bool waveOverride = false;

            bool shootingReset = true;

            bool inWave;
            int waveNumber = 0;

            float lastFPS = 0;

            timpy.getEntity()->forceSpawn();

            std::vector<std::vector<std::unique_ptr<Entity>>> waveSetEEnemies;
            waveSetEEnemies.reserve(5);
            std::vector<std::vector<std::unique_ptr<Enemy>>> waveSetEnemies;
            waveSetEnemies.reserve(5);

            while(state.started && !state.quit) {

                bool leftMovement = false;
                bool rightMovement = false;

                if(waveNumber == 0) {
                    resetState();
                    timpy.setSecondaryWeapon(nullptr);
                    timpy.setAbility(none);
                }

                inWave = true;
                waveNumber++;

                int waveSetLocation = (waveNumber-1) % 5;
                if(waveSetLocation == 0) {
                    waveSetEEnemies.clear();
                    waveSetEnemies.clear();
                    for(auto& enemy : state.setEnemies) {
                        enemy = 0;
                    }
                    for(int i = 0; i < 5; i++) {
                        std::vector<std::unique_ptr<Entity>> eEnemies;
                        std::vector<std::unique_ptr<Enemy>> enemies;

                        getWaveEnemyEntities(waveNumber + i,&enemySpawns, eEnemies, enemies);

                        waveSetEEnemies.push_back(std::move(eEnemies));
                        waveSetEnemies.push_back(std::move(enemies));
                    }
                    for(auto& set : waveSetEnemies) {
                        for(auto& enemies : set) {
                            state.setEnemies[enemies->getType()]++;
                        }
                    }
                }

                std::list<Entity*> allCharacterEntities;
                for (auto& eEnemy: waveSetEEnemies[waveSetLocation]) {
                    allCharacterEntities.push_back(eEnemy.get());
                }

                allCharacterEntities.push_back(timpy.getEntity());

                state.menu = weaponUpgrade;

                launchUpgradeMenu(state);
                loadUpgradeMenu(state);
                while((waveNumber-1) % 5 == 0 && (state.menu == weaponUpgrade || state.menu == abilityUpgrade || state.menu == playerUpgrade) && !state.quit) {
                    while(SDL_PollEvent(&e) != 0) {
                        if( e.type == SDL_QUIT ) {
                            state.quit = true;
                        } else if(e.type == SDL_KEYDOWN) {
                            if(e.key.keysym.sym == SDLK_ESCAPE) {
                                closeUpgradeMenu(state,0,0);
                            }
                        } else if(e.type == SDL_MOUSEBUTTONDOWN) {
                            menuSelect(state);
                        } else if(e.type == SDL_MOUSEMOTION) {
                            mouseMove(state);
                        } else if( e.type == SDL_JOYAXISMOTION) {
                            if(SDL_GameControllerGetAxis(controller, SDL_GameControllerAxis::SDL_CONTROLLER_AXIS_LEFTY) > JOYSTICK_DEAD_ZONE) {
                                if(state.controllerStickReset) {
                                    controllerEvent(state,MENU_CONTROL::down);
                                    state.controllerStickReset = false;
                                }
                            } else if (SDL_GameControllerGetAxis(controller, SDL_GameControllerAxis::SDL_CONTROLLER_AXIS_LEFTY) < -JOYSTICK_DEAD_ZONE) {
                                if(state.controllerStickReset) {
                                    controllerEvent(state,MENU_CONTROL::up);
                                    state.controllerStickReset = false;
                                }
                            } else if(SDL_GameControllerGetAxis(controller, SDL_GameControllerAxis::SDL_CONTROLLER_AXIS_LEFTX) > JOYSTICK_DEAD_ZONE) {
                                if(state.controllerStickReset) {
                                    controllerEvent(state,MENU_CONTROL::right);
                                    state.controllerStickReset = false;
                                }
                            } else if (SDL_GameControllerGetAxis(controller, SDL_GameControllerAxis::SDL_CONTROLLER_AXIS_LEFTX) < -JOYSTICK_DEAD_ZONE) {
                                if(state.controllerStickReset) {
                                    controllerEvent(state,MENU_CONTROL::left);
                                    state.controllerStickReset = false;
                                }
                            } else {
                                state.controllerStickReset = true;
                            }
                        } else if( e.type == SDL_JOYBUTTONDOWN ) {
                            if(SDL_GameControllerGetButton(controller, SDL_GameControllerButton::SDL_CONTROLLER_BUTTON_A) == 1) {
                                controllerEvent(state,MENU_CONTROL::select);
                            } else if(SDL_GameControllerGetButton(controller, SDL_GameControllerButton::SDL_CONTROLLER_BUTTON_B) == 1) {
                                closeUpgradeMenu(state,0,0);
                            } else if(SDL_GameControllerGetButton(controller, SDL_GameControllerButton::SDL_CONTROLLER_BUTTON_RIGHTSHOULDER) == 1) {
                                if(state.menu == weaponUpgrade) {
                                    showAbilityUpgradeMenu(state,0,0);
                                } else if(state.menu == abilityUpgrade) {
                                    showPlayerUpgradeMenu(state,0,0);
                                }
                            } else if(SDL_GameControllerGetButton(controller, SDL_GameControllerButton::SDL_CONTROLLER_BUTTON_LEFTSHOULDER) == 1) {
                                if(state.menu == abilityUpgrade) {
                                    showWeaponUpgradeMenu(state,0,0);
                                } else if(state.menu == playerUpgrade) {
                                    showAbilityUpgradeMenu(state,0,0);
                                }
                            } else if(SDL_GameControllerGetButton(controller, SDL_GameControllerButton::SDL_CONTROLLER_BUTTON_DPAD_UP) == 1) {
                                controllerEvent(state,MENU_CONTROL::up);
                            } else if(SDL_GameControllerGetButton(controller, SDL_GameControllerButton::SDL_CONTROLLER_BUTTON_DPAD_DOWN) == 1) {
                                controllerEvent(state,MENU_CONTROL::down);
                            } else if(SDL_GameControllerGetButton(controller, SDL_GameControllerButton::SDL_CONTROLLER_BUTTON_DPAD_LEFT) == 1) {
                                controllerEvent(state,MENU_CONTROL::left);
                            } else if(SDL_GameControllerGetButton(controller, SDL_GameControllerButton::SDL_CONTROLLER_BUTTON_DPAD_RIGHT) == 1) {
                                controllerEvent(state,MENU_CONTROL::right);
                            }
                        }
                    }

                    SDL_RenderClear(gameRenderer);

                    for (auto it = bullets.begin(); it != bullets.end();++it) {
                        it->render();
                    }

                    for (auto it =  waveSetEnemies[waveSetLocation].begin(); it !=  waveSetEnemies[waveSetLocation].end();++it) {
                        (*it)->render();
                    }

                    SDL_SetRenderDrawColor(gameRenderer, 26, 26, 26, 200);
                    SDL_RenderFillRect(gameRenderer, &fullScreenRect);

                    renderMenu(state);

                    SDL_SetRenderDrawColor(gameRenderer, 26, 26, 26, 255);
                    SDL_RenderPresent(gameRenderer);

                }
                timpy.setXNormalV(0);
                switch(state.weapon1) {
                    case 0:
                        timpy.setPrimaryWeapon(&revolver);
                        break;
                    case 1:
                        timpy.setPrimaryWeapon(&rifle);
                        break;
                    case 2:
                        timpy.setPrimaryWeapon(&shotgun);
                        break;
                    case 3:
                        timpy.setPrimaryWeapon(&knife);
                        break;
                    case 4:
                        timpy.setPrimaryWeapon(&laserPistol);
                        break;
                    default:
                        timpy.setPrimaryWeapon(nullptr);
                }
                switch(state.weapon2) {
                    case 0:
                        timpy.setSecondaryWeapon(&revolver);
                        break;
                    case 1:
                        timpy.setSecondaryWeapon(&rifle);
                        break;
                    case 2:
                        timpy.setSecondaryWeapon(&shotgun);
                        break;
                    case 3:
                        timpy.setSecondaryWeapon(&knife);
                        break;
                    case 4:
                        timpy.setSecondaryWeapon(&laserPistol);
                        break;
                    default:
                        timpy.setSecondaryWeapon(nullptr);
                }
                if(Weapon* weapon = timpy.getPrimaryWeapon(); weapon != nullptr) {
                    weapon->upgrade(state);
                    weapon->reset();
                }
                if(Weapon* weapon = timpy.getSecondaryWeapon(); weapon != nullptr) {
                    weapon->upgrade(state);
                    weapon->reset();
                }

                state.menu = notInMenu;

                bool waveStarted = false;
                Uint32 startWaveLoad = SDL_GetTicks();

                updateInGameText(timpy.getCombo(),waveNumber, timpy.getXP(),timpy.getHealth(), timpy.getShield());

                while(state.started && inWave && !state.quit) {

                    Uint64 start = SDL_GetPerformanceCounter();

                    Uint32 current = SDL_GetTicks();
                    float dt = (current - lastUpdate) / 1000.0f;
                    lastUpdate = current;

                    if((current-startWaveLoad)/1000.0f > 1) {
                        waveStarted = true;
                    }

                    //Controls Loop
                    while(SDL_PollEvent(&e) != 0 && state.menu != weaponUpgrade) {
                        if( e.type == SDL_QUIT ) {
                            state.quit = true;
                        } else if( e.type == SDL_KEYDOWN ) {
                            if(e.key.keysym.sym == SDLK_1) {
                                state.developerMode = !state.developerMode;
                            }
                            if(e.key.keysym.sym == SDLK_2 && state.developerMode) {
                                waveNumber = 30;
                                waveOverride = true;
                            }
                            if(e.key.keysym.sym == SDLK_3 && state.developerMode) {

                            }
                            if(e.key.keysym.sym == SDLK_4 && state.developerMode) {
                                pauseEnemy = !pauseEnemy;
                            } else if(e.key.keysym.sym == SDLK_ESCAPE) {
                                state.menu = pause;
                            }
                            if(e.key.keysym.sym == SDLK_d) {
                                timpy.setXNormalV(1);
                                rightMovement = true;
                            }
                            if(e.key.keysym.sym == SDLK_a) {
                                timpy.setXNormalV(-1);
                                leftMovement = true;
                            }
                            if(e.key.keysym.sym == SDLK_l) {
                                if(state.teleportSelection) {
                                    state.tcVx = 1;
                                    state.tcMovingRight = true;
                                } else {
                                    timpy.setDirection(true);
                                }

                            } else if(e.key.keysym.sym == SDLK_j) {
                                if(state.teleportSelection) {
                                    state.tcVx = -1;
                                    state.tcMovingLeft = true;
                                } else {
                                    timpy.setDirection(false);
                                }
                            } else if(e.key.keysym.sym == SDLK_k) {
                                if(state.teleportSelection) {
                                    state.tcVy = 1;
                                    state.tcMovingDown = true;
                                }
                            } else if(e.key.keysym.sym == SDLK_i) {
                                if(state.teleportSelection) {
                                    state.tcVy = -1;
                                    state.tcMovingUp = true;
                                }
                            } else if(e.key.keysym.sym == SDLK_w) {
                                timpy.changeWeapon();
                            } else if(e.key.keysym.sym == SDLK_r) {
                                timpy.getWeapon()->forceReload();
                            }
                            if(e.key.keysym.sym == SDLK_SPACE && waveStarted && !state.c4Placed) {
                                if((shootingReset || state.resetShooting) && !state.teleportSelection) {
                                    timpy.getWeapon()->shoot(&eBullets,&bullets,state,timpy.getDirection(),timpy.getEntity()->getRect().x,timpy.getEntity()->getRect().y);
                                    shootingReset = false;
                                    state.resetShooting = false;
                                }
                            } else if(e.key.keysym.sym == SDLK_e) {
                                timpy.useAbility(state);
                            }
                        } else if(e.type == SDL_KEYUP) {
                            if(e.key.keysym.sym == SDLK_d)
                                rightMovement = false;
                            if(e.key.keysym.sym == SDLK_a)
                                leftMovement = false;
                            if(!leftMovement && !rightMovement) {
                                timpy.setXNormalV(0);
                            } else if (leftMovement) {
                                timpy.setXNormalV(-1);
                            } else {
                                timpy.setXNormalV(1);
                            }

                            if(e.key.keysym.sym == SDLK_l) {
                                state.tcMovingRight = false;
                            } else if(e.key.keysym.sym == SDLK_j) {
                                state.tcMovingLeft = false;
                            } else if(e.key.keysym.sym == SDLK_k) {
                                state.tcMovingDown = false;
                            } else if(e.key.keysym.sym == SDLK_i) {
                                state.tcMovingUp = false;
                            }

                            if(!state.tcMovingLeft && !state.tcMovingRight) {
                                state.tcVx = 0;
                            } else if (state.tcMovingLeft) {
                                state.tcVx = -1;
                            } else {
                                state.tcVx = 1;
                            }

                            if(!state.tcMovingUp && !state.tcMovingDown) {
                                state.tcVy = 0;
                            } else if (state.tcMovingUp) {
                                state.tcVy = -1;
                            } else {
                                state.tcVy = 1;
                            }

                            if(e.key.keysym.sym == SDLK_SPACE) {
                                shootingReset = true;
                            }
                        } else if( e.type == SDL_JOYAXISMOTION) {
                            if(SDL_GameControllerGetAxis(controller, SDL_GameControllerAxis::SDL_CONTROLLER_AXIS_TRIGGERRIGHT) > JOYSTICK_DEAD_ZONE) {
                                if(shootingReset && !state.teleportSelection && !state.c4Placed) {
                                    if(timpy.getWeapon()->shoot(&eBullets,&bullets,state,timpy.getDirection(),timpy.getEntity()->getRect().x,timpy.getEntity()->getRect().y)) {
                                        SDL_GameControllerRumble( controller, 0xFFFF * 3 / 4, 0xFFFF * 3 / 4, 150 );
                                    } else {
                                        SDL_GameControllerRumble( controller, 0xFFFF * 3 / 4, 0xFFFF * 3 / 4, 75 );
                                    }
                                    shootingReset = false;
                                }
                            } else {
                                shootingReset = true;
                            }

                            if(SDL_GameControllerGetAxis(controller, SDL_GameControllerAxis::SDL_CONTROLLER_AXIS_RIGHTX) > JOYSTICK_DEAD_ZONE) {
                                if(state.teleportSelection) {
                                    state.tcVx = 1;
                                } else {
                                    timpy.setDirection(true);
                                }
                            } else if (SDL_GameControllerGetAxis(controller, SDL_GameControllerAxis::SDL_CONTROLLER_AXIS_RIGHTX) < -JOYSTICK_DEAD_ZONE) {
                                if(state.teleportSelection) {
                                    state.tcVx = -1;
                                } else {
                                    timpy.setDirection(false);
                                }
                            } else {
                                state.tcVx = 0;
                            }

                            if(SDL_GameControllerGetAxis(controller, SDL_GameControllerAxis::SDL_CONTROLLER_AXIS_RIGHTY) > JOYSTICK_DEAD_ZONE) {
                                if(state.teleportSelection) {
                                    state.tcVy = 1;
                                }
                            } else if(SDL_GameControllerGetAxis(controller, SDL_GameControllerAxis::SDL_CONTROLLER_AXIS_RIGHTY) < -JOYSTICK_DEAD_ZONE) {
                                if(state.teleportSelection) {
                                    state.tcVy = -1;
                                }
                            } else {
                                state.tcVy = 0;
                            }

                            if(SDL_GameControllerGetAxis(controller, SDL_GameControllerAxis::SDL_CONTROLLER_AXIS_LEFTX) > JOYSTICK_DEAD_ZONE) {
                                timpy.setXNormalV(1);
                            } else if (SDL_GameControllerGetAxis(controller, SDL_GameControllerAxis::SDL_CONTROLLER_AXIS_LEFTX) < -JOYSTICK_DEAD_ZONE) {
                                timpy.setXNormalV(-1);
                            } else {
                                timpy.setXNormalV(0);
                            }
                        } else if(e.type == SDL_JOYDEVICEADDED ) {
                            loadController();
                        } else if (e.type == SDL_JOYDEVICEREMOVED) {
                            controller = nullptr;
                        } else if( e.type == SDL_JOYBUTTONDOWN ) {
                            if(SDL_GameControllerGetButton(controller, SDL_GameControllerButton::SDL_CONTROLLER_BUTTON_Y) == 1) {
                                timpy.changeWeapon();
                            } else if(SDL_GameControllerGetButton(controller, SDL_GameControllerButton::SDL_CONTROLLER_BUTTON_B) == 1) {
                                timpy.useAbility(state);
                            } else if(SDL_GameControllerGetButton(controller, SDL_GameControllerButton::SDL_CONTROLLER_BUTTON_START) == 1) {
                                state.menu = pause;
                            } else if(SDL_GameControllerGetButton(controller, SDL_GameControllerButton::SDL_CONTROLLER_BUTTON_X) == 1) {
                                timpy.getWeapon()->forceReload();
                            }
                        }
                    }

                    if(state.teleportSelection) {
                        pauseEnemy = true;
                        state.teleportCursorX += state.tcVx*dt*scale(300);
                        state.teleportCursorY += state.tcVy*dt*scale(300);
                        if((current-state.startSelection)/2000.0f > 1) {
                            state.teleportSelection = false;
                            timpy.getEntity()->setPosition(state.teleportCursorX, state.teleportCursorY);
                            pauseEnemy = false;
                        }
                    }

                    if(timpy.getWeapon()->isReloadable()) {
                        updateTimeToShoot(scalePlayerUI(timpy.getWeapon()->reload(dt)));
                    } else {
                        updateTimeToShoot(scalePlayerUI(75));
                    }

                    updateTimeToAbility(scalePlayerUI(timpy.charge( state)));
                    if(timpy.getWeapon()->wasJustReloaded()) {
                        SDL_GameControllerRumble( controller, 0xFFFF * 1 / 2, 0xFFFF * 1 / 2, 50 );
                    }

                    bool robotAlive = false;
                    bool playerAlive = true;

                    //Render/Move Bullets
                    for (auto it = bullets.begin(); it != bullets.end();) {
                        if(it->move(dt, platforms, state.developerMode)) {
                            eBullets.erase(it->getIterator());
                            it = bullets.erase(it);
                        } else {
                            it->render();
                            ++it;
                        }
                    }

                    //Render/Move/Collision Enemies
                    bool playerDamaged = false;
                    SDL_SetRenderDrawColor(gameRenderer, 255, 0, 0, 255);
                    int enemiesAlive = 0;
                    for (auto it =  waveSetEnemies[waveSetLocation].begin(); it !=  waveSetEnemies[waveSetLocation].end();++it) {
                        bool firstLoop = false;
                        bool abilityDamgage = false;
                        if(!(*it)->getEntity()->isSpawned()) {
                            (*it)->getEntity()->spawn(state.enemiesAlive <= 5);
                            firstLoop = true;
                        }
                        if((*it)->getEntity()->isAlive() && (*it)->getEntity()->isSpawned()) {
                            if(!firstLoop && waveStarted && !pauseEnemy && state.menu != weaponUpgrade) {
                                (*it)->move(dt, platforms,state);
                            }
                            (*it)->render();
                            if(!(*it)->didAlreadyCollide() && timpy.getWeapon()->getType() == Weapon_Type::knife && Entity::isColliding((*it)->getEntity()->getRect(),timpy.getWeaponRect())) {
                                (*it)->getEntity()->damage(timpy.getWeapon()->getDamage());
                                (*it)->knifeColliding();
                            } else {
                                if(timpy.getWeapon()->getType() == Weapon_Type::knife && !Entity::isColliding((*it)->getEntity()->getRect(),timpy.getWeaponRect())) {
                                    (*it)->knifeNotColliding();
                                }
                                if( Entity::isColliding((*it)->getEntity()->getRect(),timpy.getHitRect())) {
                                    if(timpy.getEntity()->getRect().y + (timpy.getEntity()->getRect().h-(*it)->getEntity()->getRect().h) < (*it)->getEntity()->getRect().y
                                        && timpy.getAbility() == Ability::bounce && timpy.isCharged()) {
                                            timpy.getEntity()->setYVelocity(-1800);
                                            (*it)->getEntity()->damage(5);
                                            timpy.setInvincible(true);
                                            abilityDamgage = true;
                                        } else if(!timpy.isInvincible()) {
                                            int randomNumber = rand() % 100;
                                            int dodgeChance = state.playerLevels[dodge] == 0 ? 0 : state.playerProperties[dodge][state.playerLevels[dodge]-1][1];
                                            if(randomNumber >= dodgeChance) {
                                                if(timpy.damage(state)) {
                                                    playerAlive = false;
                                                    waveNumber = 0;
                                                }
                                                SDL_GameControllerRumble( controller, 0xFFFF * 3 / 4, 0xFFFF * 3 / 4, 750 );
                                                updateInGameText(timpy.getCombo(),waveNumber,timpy.getXP(),timpy.getHealth(), timpy.getShield());
                                                playerDamaged = true;
                                            }
                                            (*it)->getEntity()->damage(5);
                                        }

                                }
                            }
                            for(auto bit = bullets.begin(); bit != bullets.end();) {
                                if(state.developerMode) {
                                    SDL_SetRenderDrawColor(gameRenderer,0,0,255,255);
                                    SDL_Rect temp = bit->getTrailingRect();
                                    SDL_RenderFillRect(gameRenderer, &temp);
                                }
                                if(Entity::isColliding((*it)->getEntity()->getRect(),bit->getTrailingRect())) {
                                    explosion.play();
                                    if(bit->decreaseStrength()) {
                                        eBullets.erase(bit->getIterator());
                                        bit = bullets.erase(bit);
                                    } else {
                                        ++bit;
                                    }
                                    (*it)->getEntity()->damage(timpy.getWeapon()->getDamage());
                                    break;
                                }
                                ++bit;
                            }
                            if(state.developerMode) {
                                SDL_RenderDrawRect(gameRenderer,&(*it)->getEntity()->getRect());
                            }
                            if(state.c4Exploded) {
                                int c4x = timpy.getC4Entity()->getRect().x;
                                int c4y = timpy.getC4Entity()->getRect().y;
                                if(pow(pow(c4x - (*it)->getEntity()->getRect().x,2)+pow(c4y - (*it)->getEntity()->getRect().y,2),0.5) < scale(200)) {
                                    (*it)->getEntity()->damage(state.abilityProperties[c4][state.abilityLevels[c4]-1][2]);
                                    abilityDamgage = true;
                                }
                            }
                            if(!(*it)->getEntity()->isAlive()) {
                                explosions.emplace_back((*it)->getEntity()->getRect().x+(*it)->getEntity()->getRect().w/2,(*it)->getEntity()->getRect().y+(*it)->getEntity()->getRect().h/2,gameRenderer);
                                if(!playerDamaged) {
                                    timpy.changeXP((*it)->getDifficulty());
                                    timpy.killEnemy(state);
                                    if(!abilityDamgage) {
                                        if(state.abilitiesKills < state.abilityProperties[timpy.getAbility()][state.abilityLevels[timpy.getAbility()]][1] && timpy.getAbility() != none && !timpy.isCharged())
                                            state.abilitiesKills++;
                                    }
                                }
                                updateInGameText(timpy.getCombo(),waveNumber, timpy.getXP(),timpy.getHealth(), timpy.getShield());
                            } else {
                                for(auto& teleport : teleports) {
                                    if(Entity::isColliding((*it)->getEntity()->getRect(),teleport)) {
                                        (*it)->getEntity()->despawn();
                                    }
                                }

                            }
                        }
                        if((*it)->getEntity()->isAlive()) {
                            robotAlive = true;
                            enemiesAlive++;
                        }
                    }

                    state.enemiesAlive = enemiesAlive;

                    for(auto it = explosions.begin();it != explosions.end();) {
                        if(it->finished()) {
                            it = explosions.erase(it);
                        } else {
                            it->render();
                            it->advance();
                            ++it;
                        }
                    }

                    state.c4Exploded = false;

                    if(!playerAlive || waveOverride) {
                        SDL_GameControllerRumble( controller, 0xFFFF * 3 / 4, 0xFFFF * 3 / 4, 750 );
                        inWave = false;
                        waveOverride = false;
                    } else {
                        inWave = robotAlive;
                    }

                    if(timpy.getEntity()->isSpawned()) {
                        if(waveStarted) {
                            timpy.move(dt, platforms,state);
                        }
                        if(timpy.isInvincible()) {
                            SDL_SetTextureColorMod(timpy.getEntity()->getTexture()->getTexture(),0,150,255);
                            timpy.tickInvicibilty(dt);
                        } else {
                            SDL_SetTextureColorMod(timpy.getEntity()->getTexture()->getTexture(),255,255,255);
                        }
                        timpy.render();
                        state.playerX = timpy.getEntity()->getRect().x;
                        state.playerTileX = state.playerX/TILE_SIZE_SCALED;
                        state.playerTileY = (timpy.getEntity()->getRect().y-state.camY)/TILE_SIZE_SCALED;

                        if(state.developerMode) {
                            SDL_Rect playerTile = {(state.playerTileX)*TILE_SIZE_SCALED, state.playerTileY*TILE_SIZE_SCALED+state.camY,TILE_SIZE_SCALED,TILE_SIZE_SCALED};
                            SDL_SetRenderDrawColor(gameRenderer, 225, 225, 0, 255);
                            SDL_RenderDrawRect(gameRenderer, &playerTile);
                        }

                        for(auto& teleport : teleports) {
                            if(Entity::isColliding(timpy.getEntity()->getRect(),teleport)) {
                                timpy.getEntity()->forceSpawn();
                            }
                        }
                    }

                    SDL_SetRenderDrawColor(gameRenderer, 0, 255, 0, 255);
                    if(state.developerMode) {
                        SDL_RenderDrawRect(gameRenderer,&timpy.getEntity()->getRect());
                        SDL_RenderDrawRect(gameRenderer, timpy.getWheelRect());
                        SDL_Rect tempHitRect = timpy.getHitRect();
                        SDL_RenderDrawRect(gameRenderer, &tempHitRect);
                    }

                    renderInGameText(state.developerMode, lastFPS, waveStarted);

                    renderPlayerUI(&timpy);

                    if(state.teleportSelection) {
                        SDL_SetTextureColorMod(teleportCursor.getTexture(),0,150,255);
                        teleportCursor.render(state.teleportCursorX,state.teleportCursorY);
                    }

                    SDL_SetRenderDrawColor(gameRenderer, 16, 16, 16, 255);
                    SDL_RenderPresent(gameRenderer);

                    Uint64 end = SDL_GetPerformanceCounter();

                    float elapsed = (end - start) / (float)SDL_GetPerformanceFrequency();
                    lastFPS = (1.0f / elapsed);

                    if(controller != nullptr && state.menu == pause) {
                        controllerEvent(state,MENU_CONTROL::connect);
                    }

                    while(state.menu == pause && !state.quit && state.started) {
                        pauseScreen();
                        Uint32 current = SDL_GetTicks();
                        lastUpdate = current;
                    }

                }
            }
        }

    }
    close();
    return 0;
}

void resetState() {
    state.c4Placed = false;

    state.upgradeIncreaseFactor = 0;

    for(auto& enemy : state.setEnemies) {
        enemy = 0;
    }

    for(auto& level : state.weaponLevels) {
        level = 0;
    }
    state.weaponLevels[0] = 1;

    for(auto& level : state.abilityLevels) {
        level = 0;
    }

    for(auto& level : state.playerLevels) {
        level = 0;
    }
    timpyPointer->reset(state);
    loadUpgradeMenu(state);
}

void getWaveEnemyEntities(int waveNumber, std::vector<Spawn>* spawns, std::vector<std::unique_ptr<Entity>>& entities, std::vector<std::unique_ptr<Enemy>>& enemies) {
    int totalDifficulty = 0;
    while(totalDifficulty < waveNumber) {
        int enemyType = rand() % 100 + 1;
        if(enemyType <= (*state.currentWeight)[0] && totalDifficulty+Robor::difficulty <= waveNumber) {
            totalDifficulty += Robor::difficulty;
            entities.emplace_back(std::make_unique<Entity>(spawns, gameRenderer, Robor::health));
            enemies.emplace_back(std::unique_ptr<Enemy>(new Robor(entities.back().get())));
        } else if(enemyType > (*state.currentWeight)[0] && enemyType <= (*state.currentWeight)[1] && totalDifficulty+Roborto::difficulty <= waveNumber) {
            totalDifficulty += Roborto::difficulty;
            entities.emplace_back(std::make_unique<Entity>(spawns, gameRenderer, Roborto::health));
            enemies.emplace_back(std::unique_ptr<Enemy>(new Roborto(entities.back().get())));
        } else if(enemyType > (*state.currentWeight)[1] && enemyType <= (*state.currentWeight)[2] && totalDifficulty+Robro::difficulty <= waveNumber) {
            totalDifficulty += Robro::difficulty;
            entities.emplace_back(std::make_unique<Entity>(spawns, gameRenderer, Robro::health));
            enemies.emplace_back(std::unique_ptr<Enemy>(new Robro(entities.back().get())));
        } else if(enemyType > (*state.currentWeight)[2] && enemyType <= (*state.currentWeight)[3] && totalDifficulty+Romo::difficulty <= waveNumber) {
            totalDifficulty += Romo::difficulty;
            entities.emplace_back(std::make_unique<Entity>(spawns, gameRenderer, Romo::health));
            enemies.emplace_back(std::unique_ptr<Enemy>(new Romo(entities.back().get())));
        } else if(enemyType > (*state.currentWeight)[3] && enemyType <= (*state.currentWeight)[4] && totalDifficulty+Roo::difficulty <= waveNumber) {
            totalDifficulty += Roo::difficulty;
            entities.emplace_back(std::make_unique<Entity>(spawns, gameRenderer, Roo::health));
            enemies.emplace_back(std::unique_ptr<Enemy>(new Roo(entities.back().get())));
        }
    }
}